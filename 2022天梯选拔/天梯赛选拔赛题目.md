## 星月诞生(5分)

白茶在大断层的千层塔曾获得了一个 AI ，并利用其在遏制果冻的阴谋时立下赫赫战功。

该 AI 实际上是一块芯片。最近，白茶定制了一只仿生机械猫，其毛色乌黑，宛若星空；其瞳色澄澈，宛如星辰；其体型细长，宛如弯月。白茶把芯片植入机械猫内，赋予其“新生”，并将其起名为 `星月` 。

为了纪念这一特殊的时刻，请你连续输出三遍星月的名字 `Xing Yue` ，你可以用一个换行符或空格隔开。

无输入。

请输出相应的内容。

###### 子任务

```plain
tt101-1[] 5
```





## 星月摸鱼(5分)

作为猫猫，当然要能动啦！所以，白茶正在给星月训练动作模块。因为星月是猫科机械，所以白茶想要训练星月摸鱼的技巧。经过一段训练后，效果显著。于是白茶给星月作了长为 $n$ 天的测验。这 $n$ 天编号为 $1$ 到 $n$ 。白茶发现，在编号为奇数的天里，星月都摸了 $a$ 条鱼；在编号为偶数的天里，星月都摸了 $b$ 条鱼。请问，在这 $n$ 天里，星月一共摸了多少鱼？

输入一行三个整数 $n,a,b$ ，用一个空格隔开。$n$ 是偶数，$0\le n,a,b\le10^3$ 。

输出一行一个整数，代表星月摸鱼总数。

###### 输入样例

```c++
4 1 3
```

###### 输出样例

```c++
8
```

###### 子任务

```plain
tt102-1[] 1
tt102-2[] 1
tt102-3[] 1
tt102-4[] 1
tt102-5[] 1
```



## 星月划水(10分)

众所周知，猫猫会游泳(猫：喵喵喵？？？)。所以，白茶想训练星月划水的能力。划水训练是无监督学习，所以白茶偷闲时星月都在自动划水。

因为逢周一晚上图书馆闭馆，所以白茶全天摆烂，星月可以全天不停划水；在周一以外的工作日，白茶晚上没课，会花费 $4h$ 训练星月别的项目，剩余时间星月不停划水；在周末，白茶会早晚各花费 $4h$ 训练星月别的项目，其余时间星月不停划水。

输入一行一个整数 $x(1\le x\le 7)$ ，代表今天是星期几

输出一行一个整数，代表今天星月划水多少小时

###### 输入样例1

```c++
1
```

###### 输出样例1

```c++
24
```

###### 输入样例2

```c++
2
```

###### 输出样例2

```c++
20
```

###### 子任务

```plain
tt103-1[] 1
tt103-2[] 1
tt103-3[] 1
tt103-4[] 1
tt103-5[] 2
tt103-6[] 2
tt103-7[] 2
```





## 星月训练(10分)

白茶想要训练星月的基本逻辑能力，所以给了星月一大堆小学二年级的判断题，星月需要判断若干命题，例如 `水是剧毒的` ，是否是真命题。

白茶给了星月 $n$ 个命题，对第 $i$ 个命题，若命题是真命题，记作 $1$ ，否则记作 $0$ ，记星月的输出为 $a_i$ ；本题的答案为 $b_i$ 。

白茶需要评判星月训练的结果，所以他使用查准率和查全率来衡量。通俗地说，查准率是认为对的里边多少是真的对的；查全率是真的对的里边判对了多少个。

具体定义：

1. 正确肯定（True Positive,TP）数：  预测为真，实际为真的数量
2. 正确否定（True Negative,TN）数：预测为假，实际为假的数量
3. 错误肯定（False Positive,FP）数：  预测为真，实际为假的数量
4. 错误否定（False Negative,FN）数：预测为假，实际为真的数量

那么查准率P(precision)和查全率(又称召回率)R(recall)的计算公式为：
$$
P=\frac{TP}{TP+FP}\ \ \quad
R=\frac{TP}{TP+FN}
$$
给定训练结果，请你求出查准率和查全率。

输入一行一个整数 $n(1\le n\le 5\times10^3)$ ，代表命题数

接下来输入 $n$ 行，第 $i$ 行有两个整数 $a_i, b_i$ ，代表星月的判断和本题的答案，$0\le a_i,b_i\le 1$ 

保证题目输入满足： $TP+FP >0$ 且 $TP+FN > 0$ 

输出一行两个实数，代表查准率和查全率。你的答案被认为是正确的当且仅当你的答案与标准答案的相对误差或绝对误差其一不超过 $0.01$ 

###### 输入样例1

```c++
4
1 0
0 1
0 0
1 1
```

###### 输出样例1

```c++
0.500000 0.500000
```

###### 输入样例2

```c++
6
1 1
1 1
0 1
0 1
0 1
1 0
```

###### 输出样例2

```c++
0.666667 0.400000
```

###### 子任务

```plain
tt104-1[] 1
tt104-2[] 1
tt104-3[] 2
tt104-4[] 2
tt104-5[] 2
tt104-6[] 1
tt104-7[] 1
```

###### SPJ

```c++
#include "testlib.h"
typedef long long ll;
typedef double db;
using namespace std;
db so1, so2, sa1, sa2;
ll n;
signed main(int argc, char *argv[])
{
    registerTestlibCmd(argc, argv);
    n = inf.readLong();
    so1 = ouf.readReal();
    so2 = ouf.readReal();
    sa1 = ans.readReal();
    sa2 = ans.readReal();
    if (!doubleCompare(sa1, so1, 1e-2) || !doubleCompare(sa2, so2, 1e-2))
    {
        quitf(_wa, "WA");
    }
    quitf(_ok, "AC");
}
```





## 星月选课(15分)

在第五轮选课结束后，白茶发现全部选修课都被退选了，他绝望地喊出 “日内瓦，退学！”。冷静过后，他认为：此诚危急存亡之秋也。于是，白茶开始认真思考往后如何才能凑够学分。他花费一个时间戳单位就想出了结论。为了检验星月逻辑训练的成果，白茶想让星月解决这个问题。

已知还有 $n$ 门选修课可选，第 $i$ 门课的学分是 $w_i$ ，选中的概率是 $p_i$ 。每门课可选可不选，且假设白茶从不挂科。请问，它能获得的学分的最大数学期望值是多少？

输入一行一个整数 $n(1\le n\le10^4)$ ，代表课程数。

接下来输入一行 $n$ 个整数，第 $i$ 个整数代表第 $i$ 门课的学分 $w_i(1\le w_i\le8)$

接下来输入一行 $n$ 个一位小数，第 $i$ 个实数代表第 $i$ 门课的选中概率 $p_i(0.1\le p_i\le1.0)$

输出一行一个实数代表最大学分的数学期望值。你的答案被认为是正确的当且仅当你的答案与标准答案的相对误差或绝对误差其一不超过 $0.01$ 

###### 输入样例

```c++
2
2 3
0.5 0.5
```

###### 输出样例

```c++
2.5
```

###### 样例解释

假设两门课都选，有四种情况：

- 第一门选上第二门选上，得 $5$ 学分
- 第一门选上第二门落选，得 $2$ 学分
- 第一门落选第二门选上，得 $3$ 学分
- 第一门落选第二门落选，得 $0$ 学分

$p=0.5$ ，四种情况等概率，期望值为 $(5+2+3+0)\div 4=2.5$ 学分

假设只选第一门课，要么选上得 $2$ 学分，要么落选没分，期望值为 $1$ 学分

假设只选第二门课，要么选上得 $3$ 学分，要么落选没分，期望值为 $1.5$ 学分

假设不选，得 $0$ 学分。

在所有四种选课方案里，第一种最优，其期望值为 $2.5$ 学分。

###### 子任务

```c++
tt105-1[] 1
tt105-2[] 2
tt105-3[] 2
tt105-4[] 2
tt105-5[] 2
tt105-6[] 2
tt105-7[] 2
tt105-8[] 2
```

###### SPJ

```c++
#include "testlib.h"
typedef long long ll;
typedef double db;
using namespace std;
db so1, sa1;
ll n;
signed main(int argc, char *argv[])
{
    registerTestlibCmd(argc, argv);
    n = inf.readLong();
    so1 = ouf.readReal();
    sa1 = ans.readReal();
    if (!doubleCompare(sa1, so1, 1e-2))
    {
        quitf(_wa, "WA");
    }
    quitf(_ok, "AC");
}
```





## 星月学语(15分)

白茶发现每次与星月交互，它的回答都很不理想。为了让星月拥有更高的语言智能，白茶请教了这学期选修 NLP 的桑泽。桑泽给出了一系列训练方案，其中最基础的第一步是分词训练。具体而言，每一个输入的句子，星月都应当能划分出每个单词。为了检验成果，桑泽一口气说了许多句子，并提问每个句子里包含特定单词多少个。

特别注意，句子中包含的单词本身不能是另外一个单词的一部分，例如对下面句子：`he is hell, he is heaven, hehe!` ，查找单词 `he` ，因为 `he` 是 `hell` , `heaven` , `hehe` 的一部分，所以它们都不算入内，句子只包含两个 `he` 。

输入一行一个整数 $n(1\le n\le20)$ ，代表测试个数。

每个测试测试包含两行。第一行输入一个仅由小写英文字母、空格和标点符号 `,?!.'"-` 组成的长度不超过 $100$ 的非空字符串 $s$ ；第二行输入一个仅由小写英文字母组成的长度不超过 $100$ 非空字符串 $t$

对于每个测试，输出一行一个整数，代表 $s$ 中包含多少个单词 $t$

###### 输入样例1

```c++
3
nishuo zhinengbumen, zhinengbumen, yi, yijie yijie yijie huanle duoshaoge zuqiuxiehuizhuxi la?
yijie
yi, shu wan tai guo dui shu yue nan zai shu mian dian, jie xia lai mei ren ke shu le.
ying
ni dao gao su wo zen me jie shi?lian, lian dou bu yao le.
lian
```

###### 输出样例1

```c++
3
0
2
```

###### 输入样例2

```c++
2
tonight eight p.m., i am waiting you at sand city.
i
easy-play, rhythm-bright, one people ak kill whole area.
play
```

###### 输出样例2

```c++
1
1
```

###### 提示

你不必考虑英语或其他语言语法，例如你不应该认为 `has`, `having`, `had` 都是单词 `have` ，也不用认为 `i'm` 包含 `am` (但是在本题你应当认为 `i'm` 包含 `i` 和 `m`) 

对 C/C++ 选手， OJ 不可用 `gets` 函数，你可以用 `fgets`, `getline` 等函数代替

###### 子任务

```c++
tt106-1[] 3
tt106-2[] 3
tt106-3[] 1
tt106-4[] 3
tt106-5[] 3
tt106-6[] 2
```



## 星月观星(20分)

元丰九四五年二月三十一日夜，解衣欲睡，月色入户，欣然起行。念无与为乐者，遂至埃栋找锦乐。锦乐已寝，相与逐于中庭。

庭下星空璀璨，繁星密布，叹为观止也。看见这美丽的星与月，白茶十分想拍照一张。然而愤怒的锦乐把白茶的手机摔了，所以白茶只能用星月的摄影功能来拍照。

虽然可见范围的星空为 $n\times m$ 的矩阵，但星月的摄像头分辨率为 $k\times k$ ，所以拍照只能截得星空中一个 $k\times k$ 的子矩阵。矩阵上元素若为 `*` ，代表此处有一颗星星；若为 `o` ，代表此处有一个月亮；若为 `.` ，代表此处什么也没有。白茶想用星月拍摄一张有月亮且星星数目最多的照片，请问在有月亮的条件下，星月最多能拍到多少颗星星。

输入一行三个整数 $n,m,k(1\le n,m\le50,1\le k\le\min{(n,m)})$ ，代表矩阵的大小和摄像头分辨率。

接下来输入 $n$ 行，每行 $m$ 个字符，字符的取值范围为 `.` , `*` 或 `o` ，保证 `o` 出现且仅出现一次。

输出一行一个整数，代表在有月亮的条件下，星月最多能拍到的星星数目

###### 输入样例

```c++
4 5 2
**..*
**.*.
..*o*
*..*.
```

###### 输出样例

```c++
2
```

###### 子任务

```plain
tt107-1[] 1
tt107-2[] 1
tt107-3[] 1
tt107-4[] 3
tt107-5[] 1
tt107-6[] 3
tt107-7[] 2
tt107-8[] 2
tt107-9[] 2
tt107-10[] 2
tt107-11[] 2
```





## 星月寻人(20分)

白茶听闻他的好朋友弥明因院楼搬迁而来到了自己的校区。为了给他一个惊喜，白茶打算偷偷地送给他一份礼物。但弥明尚未告诉他具体所住的宿舍，目前白茶只知道弥明是舍长，且已知舍长名会挂在宿舍门口。所以白茶打算让星月悄(正)悄(大)咪(光)咪(明)去 DFS 整个校区的宿舍楼，直到找到为止。

校区里有 $n$ 栋宿舍楼，每栋宿舍楼有 $m$ 层，宿舍楼编号从 $1$ 到 $n$ ，楼层编号从 $1$ 到 $m$ ，每层楼至多有 $k$ 间宿舍，宿舍编号从 $1$ 到 $k$ 递增，且已知每个舍长名字各异，且区分大小写。

首先输入一行三个整数 $n,m,k(1\le n,m,k\le40)$ 

接下来输入 $n\times m$ 行，每行首先输入三个整数 $a_i,b_i,c_i(1\le a_i\le n,1\le b_i\le m,1\le c_i\le k)$ ，代表在第 $a_i$ 栋宿舍楼第 $b_i$ 楼层有 $c_i$ 间宿舍。然后在同一行内输入 $c_i$ 个只含大小写英文字母、数字和下划线且长度不超过  $20$ 的非空字符串，第 $j$ 个字符串 $s_j$ 代表编号为 $j$ 的宿舍的舍长名字为 $s_j$ 

接着输入一行一个整数 $q(q\le 10)$ ，代表询问的个数

接下来输入 $q$ 行，每行输入一个只含大小写英文字母、数字和下划线且长度不超过 $20$ 的非空字符串 $p$ ，代表查询的舍长名

对于每个询问，若舍长名存在，输出三个整数分别代表他/她所在的宿舍楼编号、楼层编号和宿舍编号。若不存在，输出 `not found` 

###### 输入样例

```c++
3 6 4
1 1 3 bai_cha xing_yue dakta
1 2 2 he_feng Hyper_Chordfish
1 3 1 guo_dong
1 4 2 if_1178 mi_ming
1 5 3 jin_le sang_ze bai_fu
1 6 4 cst7 Pop_Slime yun_yan wumeibanfa
2 1 1 m1saka
2 2 1 linear_algebra
2 3 3 public protected private
2 4 1 Python
2 5 2 dayuanx HK_SHAO
2 6 4 Shuvi_Doura qaq hazy_lazy_doll3 QAQ
3 1 1 ljlnb
3 2 2 discrete_mathematics advanced_mathematics
3 3 1 bobby285271
3 4 4 noname0 asirpa Thorfinn_Karlsefni nanachi
3 5 1 Emanon
3 6 3 LiZiMing lr580 lr581
5
LiZiMing
mi_ming
QAQ
Bai_cha
lr581
```

###### 输出样例

```c++
3 6 1
1 4 2
2 6 4
not found
3 6 3
```

###### 输入样例2

```c++
2 3 2
2 1 2 compile_elegantly time_limit_enough
1 3 2 AK CE
1 1 1 tian_jiang
2 2 2 wonderful_answer run_excellently
2 3 2 TLE MLE
1 2 2 WA RE
6
WA
RE
TLE
MLE
CE
AC
```

###### 输出样例2

```c++
1 2 1
1 2 2
2 3 1
2 3 2
1 3 2
not found
```

###### 子任务

```c++
1[] 1
2[] 1
3[] 2
4[] 2
5[] 2
6[] 2
7[] 1
8[] 1
9[] 1
10[] 1
11[] 1
12[] 1
13[] 1
14[] 1
15[] 1
16[] 1
```





## 弥明爱跑步(25分)

弥明来到了新校区。弥明是一个热爱跑步的人，但他不喜欢独自跑步，所以他想找白茶作伴。白茶厌恶跑步，所以让星月陪弥明一同跑步。弥明使用部道乐跑 APP 记录跑步，并定下目标，想要与星月一同完成 $30$ 次部道乐跑任务，每个任务需要跑 $2500m$ ，并且经过两个签到点。由于每次领取任务时，弥明和星月领取到的签到点不都是一样的，而他们又想一起同行。于是，他们决定，从一个起始点出发，按照特定顺序一起依次经过他们加起来的四个签到点。他们想要知道，对于给定的起始点和四个签到点，是否存在一个顺序，使得他们能跑够 $2500m$（即跑的总距离大于等于 $2500m$）？如果能，他们还想知道最少需要跑多远？

假设起始点和签到点均分布在平面直角坐标系上，并且都是整点（即横纵坐标均为整数）。假设两点之间的距离均取直线距离。规定输入输出中所有数值的单位为 $m$。

注：为简单起见，假定他们两个加起来在同一时刻只能选择一个签到点，此时若经过了其他尚未选择的签到点，不算做经过这些签到点。

首先输入一行一个整数 $t \ (1\le t\le10^3)$，代表询问的次数。

对于每个询问，接下来输入 $5$ 行，每行两个整数 $x_i,y_i \ (-10^4\le x,y\le10^4)$，依次代表起始点和四个签到点的坐标。

对于每个询问，若不存在一个顺序使得他们能跑够 $2500m$，在一行内输出`no`；若存在一个顺序使得他们能跑够 $2500m$，在一行内输出最少需要跑的总路程（四舍五入取整数）。

###### 输入样例

```C++
2
0 0
0 450
0 -450
450 0
-450 0
100 100
400 0
300 0
200 0
100 0
```

###### 输出样例

```c++
2623
no
```

###### 提示

对于第一个询问，起始点是 $O(0,0)$，四个签到点分别是 $A(0,450),B(0,-450),C(450,0),D(-450,0)$。

如果走路线 $OABCD$，距离是 $OA+AB+BC+CD=450+900+450\sqrt{2}+900=2500+2500\sqrt{2}\approx2886$；

如果走路线 $OACBD$，距离是 $OA+AC+CB+BD=450+450\sqrt2+450\sqrt2+450\sqrt2=450+1350\sqrt2\approx2359$，不够 $2500$，舍去；

如果走路线 $OACDB$，距离是 $OA+AC+CD+DB=450+450\sqrt2+900+450\sqrt2=1350+900\sqrt2\approx2623$；

如果走其他的路线，可以计算发现，其距离均为上面的三个结果之一。

在有效距离 $2886,2623$ 里，$2623$ 最小，故答案为 $2623$。

对于第二个询问，起始点是 $O(100,100)$，四个签到点分别是 $A(400,0),B(300,0),C(200,0),D(100,0)$，如果选择路线 $OBDAC$，其距离最长，距离约为 $924$，最长的距离也小于 $2500$，所以没有一个距离可以满足，故输出 `no`。

注：本询问计算出的所有距离为 $400,500,541,600,616,624,641,716,724,741,816,824,841,916,924$ 。

###### 子任务

```plain
1[] 2
2[] 2
3[] 2
4[] 2
5[] 2
6[] 2
7[] 2
8[] 2
9[] 3
10[] 3
11[] 3
```



## 弥明破阵法(25分)

弥明在跑步时无意间捡到一份席格玛神秘传送阵法图，据称只要能破解这份失传的阵法，就能够实现超越空间乃至时间距离的传送技术。该阵法图是一个 $n\times m$ 矩阵 $a$，矩阵的每个元素符号有不同的取值，代表它是不同类型的席格玛符号。

对矩阵的一个元素符号 $a_{x_1,y_1}$ ，与它相邻的元素符号 $a_{x_2,y_2}$ 下标满足 $|x_1-x_2|\le 1,|y_1-y_2|\le 1$ 。相邻且类型相等的元素符号属于同一个术式，这种关系具有传递性，例如当满足 $a_{1,1}=a_{1,2}=a_{1,3}$ 时， $a_{1,1},a_{1,2},a_{1,3}$ 属于同一个术式。术式的复杂度是它包含的所有元素符号的数目。复杂度相同的术式属于同一个术系。术系的丰富度是它包含的术式的复杂度之和。

请你帮助弥明计算该阵法图的术系数量并求出最高丰富度的术系的丰富度。

输入一行两个整数 $n,m(1\le n,m,n\times m\le10^6)$ ，代表矩阵的大小

接下来输入 $n$ 行，每行 $m$ 个整数，第 $i$ 行第 $j$ 个整数代表矩阵元素 $a_{i,j}(0\le a_{i,j}\le 10^9)$

输出一行两个整数，代表该阵法图的术系数量和最高丰富度的术系的丰富度

###### 输入样例1

```c++
2 2
01
10
```

###### 输出样例1

```c++
2 4
```

###### 输入样例2

```c++
6 8
2 1 1 1 1 1 1 2
1 2 2 0 0 2 2 1
1 2 2 5 5 2 2 1
1 2 2 5 5 2 2 1
1 2 2 0 0 2 2 1
2 1 1 1 1 1 1 2
```

###### 输出样例2

```c++
4 20
```

###### 输入样例3

```c++
31 45
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 9 3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 5 6 4 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 9 1 8 7 8 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 5 8 7 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 8 8 0 0 0 0 4 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 9 3 4 0 0 0 0 0 7 4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 7
0 0 0 0 0 0 0 0 0 0 0 0 0 7 4 5 5 0 0 0 0 0 0 3 6 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 7 4
0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 8 0 0 0 0 0 0 0 7 8 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 1 8 8 0
0 0 0 0 0 0 0 0 0 0 0 0 4 9 6 0 0 0 0 0 0 0 0 4 4 9 0 0 0 0 0 0 0 0 0 0 0 0 0 8 2 2 9 0 0
0 0 0 0 0 0 0 0 0 0 0 4 6 4 0 0 0 0 0 0 0 0 0 2 7 1 4 9 0 0 0 0 0 0 0 0 0 0 5 7 9 6 0 0 0
0 0 0 0 0 0 0 0 0 4 3 4 7 0 0 0 0 0 0 0 0 0 0 0 0 3 8 6 6 2 7 0 0 0 0 0 0 6 2 8 9 0 0 0 0
0 0 0 0 0 0 0 0 5 3 3 8 0 0 0 5 1 7 7 6 8 5 4 0 0 0 0 0 5 3 6 8 3 9 3 0 7 1 7 1 0 0 0 0 0
0 0 0 0 0 0 0 7 3 4 0 0 0 0 0 0 5 0 7 7 5 9 0 0 0 0 0 0 0 0 0 6 7 9 6 1 6 4 0 0 0 0 0 0 0
0 0 0 0 0 9 7 5 1 0 0 0 0 1 0 0 4 5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 7 0 0 0 0 0 0 0 0
0 0 0 0 0 4 7 8 0 0 0 0 0 0 9 2 5 8 9 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 6 7 1 0 0 0 0 0 0 4 3 7 4 1 7 9 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 6 7 4 9 0 0 0 0 0 0 4 9 8 7 8 8 8 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 4 0
0 0 0 4 1 5 0 0 0 0 0 0 0 0 7 7 3 7 4 2 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 9 8
0 0 5 1 3 0 0 0 0 0 0 0 0 0 2 8 2 5 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 4 3
0 0 6 7 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 9
0 8 6 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 4 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 0 0 0 0
0 4 2 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 1 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 3 7 9 0
0 4 2 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 4 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 7 1 5 4 1 9
6 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 1 9 9 1 2 6
3 9 4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 9 7 0 0 0 9 9 4 6 0 0 0 0 0 0 0 0 0 5 6 9 7 8 7 2
8 9 9 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 4 3 3 2 3 2 2 0 0 0 5 9 7 0 0 0 0 8 3 3 7 3 7 0
0 9 6 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 5 2 5 4 8 0 0 0 4 1 3 0 0 0 0 0 0 0 0 0 0 0
0 6 5 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 2 7 8 0 3 9 6 5 0 0 0 0 0 0 0 0 0 0 0
0 7 8 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 6 6 6 2 4 7 0 0 0 0 0 0 0 0 0 0 0 0
```

###### 输出样例3

```c++
7 595
```

###### 子任务

```plain
tt202-1[] 1
tt202-2[] 2
tt202-3[] 2
tt202-4[] 2
tt202-5[] 2
tt202-6[] 2
tt202-7[] 2
tt202-8[] 2
tt202-9[] 2
tt202-10[] 2
tt202-11[] 2
tt202-12[] 2
tt202-13[] 2
```



## 弥明超时空(25分)

弥明破解了阵法，并且发现，只要向阵法输送特高压电，该阵法就能改变强电流里电子的性质，从而打破时空规则，最终有望实现穿越！(物理学家：喵喵喵？？？)

为了产生特高压电，弥明采购了 $n$ 个编号从 $1$ 到 $n$ 递增的变电箱和 $m$ 条高压电线，并将变电箱用电线相连，最后将其中若干个变电箱连向电源，以及一个变电箱连向阵法，就能输送强大的电流到阵法里。为了达到目标，构造的电路需要满足如下限制：

1. 每条电线一端连接一个变电箱，另一端连接另一个变电箱
2. 选中其中一个变电箱作为宿变电箱让其连向阵法后，其他所有变电箱都能直接或间接通过电线使电流流向该变电箱，以提供最强的电流
3. 变电箱间不能形成闭环，即从任一个变电箱出发不能经由若干不重复的电线后回到自身，否则会产生短路爆炸

弥明求助了白茶等人，并收到了若干变电箱的电路图方案，但是所有方案都未选取宿变电箱。弥明想要知道，对给定的电路图，是否存在一种选取宿变电箱的方案，使其满足上述限制。请注意你不能对电路图增删变电箱或高压电线。

首先输入一行一个整数 $T(1\le T\le 10)$ ，代表电路图数量

对每张电路图，输入一行两个整数 $n,m(2\le n\le 2\times 10^5,1\le m\le\dfrac{n(n-1)}2)$ ，代表变电箱数和电线数

接下来输入 $m$ 行，每行两个整数 $u,v(1\le u,v\le n)$ ，代表电路存在一条连向编号为 $u,v$ 的变电箱的高压电线

保证 $1\le\sum n,\sum m\le 2\times 10^5$ 

对每张电路图，若存在满足题意限制的方案，输出 `Chronosphere ready` ，否则输入 `Low power`

###### 输入样例

```c++
4
2 1
1 1
4 2
1 2
3 4
4 4
1 2
2 3
3 4
4 2
5 4
1 2
1 3
1 4
1 5
```

###### 输出样例

```c++
Low power
Low power
Low power
Chronosphere ready
```

###### 样例解释

第一张电路图唯一一条电线两端连向同一个变电箱，不满足限制 $1,2,3$

第二张电路图无论如何选取宿变电箱，都不满足限制 $2$

第三张电路图变电箱 $2,3,4$ 形成闭环，不满足限制 $3$ 

第四张电路图至少存在两种方案，例如以 $1$ 或 $2$ 作为宿变电箱均可满足限制

本题电学知识纯属虚构，请以科学知识为准；且弥明行为危险，请勿模仿 （｡≧ _ ≦｡）

###### 子任务

```c++
tt203-1[] 2
tt203-2[] 2
tt203-3[] 2
tt203-4[] 2
tt203-5[] 3
tt203-6[] 2
tt203-7[] 3
tt203-8[] 3
tt203-9[] 2
tt203-10[] 2
tt203-11[] 2
```



## 弥明闯异界(25分)

在大家的帮助下，弥明成功创造了超时空传送器。弥明与白茶、锦乐、桑泽、星月一同回到了过去，并赶在果冻之前征服了来无回之都的千层塔，先果冻一步前往了异世界。

于是，他们在异世界历 $579$ 年 $9$ 月 $9$ 日来到了名为蓝星的剑与魔法的中世纪异世界。弥明他们并不知道果冻原本在异世界做过什么，所以他们打算先立足下来，暂时以赚取尽可能多的资金作为目标。中世纪的知识落后，他们掌握的各种知识便成了他们的资本。凭借桑泽曾训练过星月 NLP，他们拥有了同声传译猫猫。万事俱备，于是弥明一行人开办了学堂。

正所谓一花一世界，一叶一菩提；一天一本书，一周一学期，所以弥明打算每天开设 $1$ 门课程，最多开设 $n$ 天，每门课收费 $1$ 金币。此外，弥明打探到了接下来 $n$ 天预期会前来上课的学生数量，在第 $i$ 天会有 $a_i$ 名学生慕名前来。所以弥明打算事先修建一个容量为 $m$ 人的教室，当天能接受的学生数量不能超过教室容量。因物理条件限制，最大能修建容量为 $m_0$ 人的教室。

弥明设下筹够 $k$ 枚金币的目标。目标达成后弥明一行人将马上停止授课并开始闯荡异世界，谱写自己的传奇。弥明希望越早达成目标越好，并且因为建教室需要成本，故弥明希望在不影响总用时的情况下尽可能缩小教室容量。请问弥明能达成目标吗？若能，请帮他求出最佳方案。

首先输入一行一个整数 $T(1\le T\le10)$ ，代表询问的个数

对于每个询问，先输入一行三个整数 $n,m_0,k(1\le n\le10^5, 1\le m_0\le10^9,1\le k\le10^{18})$ 

保证满足 $\sum n\le2\times10^5$

接下来输入一行 $n$ 个整数，第 $i$ 个整数 $a_i(0\le a_i\le 10^9)$ 代表第 $i$ 天会来多少学生。

对每个询问，若弥明不能达成目标，输出 `tai ruo xiao le, mei you li liang` ；若弥明能达成目标，输出一行三个整数，代表达成目标所需的天数和教室容量，以及筹到的金币数。

###### 输入样例

```c++
3
6 10 7
1 1 4 5 1 4
7 8 18
1 9 1 9 1 8 0
5 1437 7186
2333 2333 2333 2333 2333
```

###### 输出样例

```c++
4 3 8
4 8 18
tai ruo xiao le, mei you li liang
```

###### 子任务

```plain
tt204-1[] 1
tt204-2[] 1
tt204-3[] 2
tt204-4[] 1
tt204-5[] 2
tt204-6[] 2
tt204-7[] 2
tt204-8[] 2
tt204-9[] 2
tt204-10[] 2
tt204-11[] 2
tt204-12[] 1
tt204-13[] 1
tt204-14[] 1
tt204-15[] 1
tt204-16[] 1
tt204-17[] 1
```



## 云烟团队激励(30分)

数月后，果冻在原本的时空里到达了来无回之都千层塔底层后，只发现了一扇被用过的一次性传送门。正当果冻纳闷之时，一个神秘人出现在果冻眼前。神秘人自称云烟，并告知了果冻他在底层悄悄目击的一切。随后，云烟带领果冻继续下行，在最终极之渊找到另外的传送方法，于是，他们又来到了异世界。在云烟的帮助下，果冻花费了更短的时间就完成了之前的事情——他们再次找来了禾枫、成立了公司、并先后发布了二次元卡牌手游 `ONU` 和游戏 `果核大陆`，再次走向巅峰。

然而好景不长，弥明他们的学堂成了世界一流大学，培养了无数人才，这些人才开创了异世界新时代，竞争公司如雨后春笋般涌现，果冻的公司迎来了危机。在此存亡之际，云烟打算对公司团队进行大刀阔斧的改革。

团队共有 $n$ 人，工号从 $1$ 到 $n$ 递增，工号为 $i$ 的员工的性格值为 $a_i$ 。云烟要把团队分成若干个子团队，他发现，若一个团队里所有人性格值的最大公因数越大，这个团队就越有竞争力。所以云烟迫切想快速计算出一个团队的性格值最大公因数。

输入一行两个整数 $n,m(1\le n\le10^5,1\le m\le2.3\times10^6)$ ，代表团队总人数和询问个数

接下来输入一行 $n$ 个整数，第 $i$ 个整数代表工号为 $i$ 的人的性格值为 $a_i(1\le a_i\le10^9)$ 

接下来输入 $m$ 行，每行两个整数 $l,r(1\le l\le r\le n)$ ，代表由工号在区间 $[l,r]$ 内的员工组成的一个子团队

对于每个询问，输出一行一个整数，代表这个子团队的性格值最大公因数

###### 输入样例

```c++
4 3
2345 360 4 67
1 2
2 3
1 4
```

###### 输出样例

```c++
5
4
1
```

###### 子任务

```c++
tt301-1[] 3
tt301-2[] 3
tt301-3[] 3
tt301-4[] 3
tt301-5[] 3
tt301-6[] 3
tt301-7[] 3
tt301-8[] 3
tt301-9[] 3
tt301-10[] 3
```





## 云烟科技争锋(30分)

在云烟强有力的公司团队改革下，果冻的公司由危转安。云烟不满足于游戏产业，他看到了科学+魔法带来的无限希望，于是他带着果冻、禾枫一同大兴科研，希望公司转型开拓更多的赛道，于是，云烟成立了大量的子公司。

现共有 $n$ 家子公司，编号从 $1$ 到 $n$ 递增。第 $i$ 家公司研究的领域的收益期望为 $a_i$ ，现在云烟有 $m$ 次操作：

1. 操作 $1$ ：更改所有收益期望值为 $x$ 的子公司的收益期望值，将这些子公司的收益期望值均改为 $y$
2. 操作 $2$ ：查询编号在区间 $[x,y]$ 的所有子公司的收益期望之和

输入一行两个整数 $n,m(1\le n,m\le10^5)$ ，子公司数和操作数

接下来输入一行 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表编号为 $i$ 的子公司初始收益期望值为 $a_i(1\le a_i\le10^9)$ 

接下来输入 $m$ 行，每行输入三个整数 $c,x,y(1\le c\le 2)$

- 若 $c=1$ ，代表执行操作 $1$ ，$1\le x,y\le 10^9$
- 若 $c=2$ ，代表执行操作 $2$ ，$1\le x\le y\le n$

对于每个操作 $2$ ，输出一行一个整数代表查询结果

###### 输入样例

```c++
4 7
20 20 200 5
2 1 4
1 20 5
2 2 4
1 10 40
2 2 4
1 5 200
2 1 4
```

###### 输出样例

```c++
245
210
210
800
```

###### 子任务

```c++
tt302-1[] 1
tt302-2[] 4
tt302-3[] 10
tt302-4[] 5
tt302-5[] 5
tt302-6[] 5
```



## 云烟蓝星对决(30分)

云烟在前往异世界前，拿走了一个最终极之渊的特级遗物。然而，正当云烟全身心搞科研之时，遗物反噬了云烟，他走火入魔并发动了世界魔法，使蓝星上所有生灵陷入昏迷。星月由于是机械猫猫所以躲过一劫。星月用金币砸醒了弥明，因弥明的心灵与金币产生了激烈反应，但星月无法再唤醒其他人。于是，弥明和星月只身前往与云烟对决。与此同时，最终极之渊迎来了周期为两千年的异变……

世界魔法有 $n$ 个魔素源泉，第 $i$ 个源泉的能量为 $a_i$ ，占领第 $i$ 个源泉需要耗费的魔力 $b_i$ 为前 $i$ 个源泉组成的集合的所有非空子集的能量和对 $10^9+7$ 取模。

严谨地说，设 $s_i=(a_1,a_2,\cdots ,a_i),s\subseteq s_i,s\neq \not0,|s|=card(s)$ (即 $|s|$ 是集合元素数)，有：
$$
b_i=\sum_s\sum_{j=1}^{|s|}a_i\bmod 10^9+7
$$
云烟和弥明轮流行动，奇数回合行动的为先手，偶数回合行动的为后手。云烟为先手。每回合双方必须选择其中一个魔法源泉 $x$ 向其中投入魔力。设第 $i$ 个源泉累计被投入了 $c_i$ 的魔力。首回合前有 $\forall 1\le i\le n,c_i=0$ 。设当前回合向源泉 $x$ 投入的魔力为 $y$ ，则 $y$ 必须满足 $y\in N,1\le y\le b_x-c_x$。当 $c_i=b_i$ 时，该源泉被占领。谁占领了最后一个未被占领的源泉，谁就能掌控世界魔法，赢得对决。

在遗物和星月各自对双方的辅助下，云烟、弥明每回合都采取对自己最优的策略进行对决。请问谁最终取得对决的胜利。

由于世界魔法稳定期有限，所以对决必须在 $2n$ 回合内分出胜负，否则将带来灾难性的后果。因此，在胜利方不变，且双方仍然采取最优策略的前提下，请问是否存在回合数不超过 $2n$ 的回合情况？

输入一行一个整数 $n(1\le n\le10^5)$ 

接下来输入一行 $n$ 个整数，第 $i$ 个整数为 $a_i(1\le a_i < 10^9+7)$  ，代表第 $i$ 个源泉的能量

第一行输出一个字符串，若先手必胜输出 `first wins` ；若后手必胜，输出 `second wins` 

第二行输出一个字符串，在你所输出的必胜状态下，若存在一种回合情况，回合数不超过 $2n$ ，输出 `yes` ，否则输出 `no`

若存在一种回合情况，回合数不超过 $2n$ ，则第三行输出一个整数 $t$ ，代表回合数；接下来输出 $t$ 行，第 $3+i$ 行每行两个整数 $x,y$ ，代表在第 $i$ 回合行动的一方对第 $x$ 个源泉投入魔力值为 $y$

###### 输入样例1

```c++
2
1 2
```

###### 输出样例1

```c++
first wins
yes
3
2 5
2 1
1 1
```

###### 输入样例2

```c++
2
3 500000002
```

###### 输出样例2

```c++
second wins
yes
2
2 3
1 3
```

###### 样例解释

对样例一，$i=1$ 时，只有一个非空子集即 $a_1$ 自身，故 $b_1=1$ ，$i=2$ 时，非空子集有三个： $(a_1),(a_2),(a_1,a_2)$ ，故 $b_2=1+2+1+2=6$ 。一种先手必胜的回合情况为先手投 $x=2,y=5$ ，后手无论如何都只能投 $y=1$ ，之后先手再投剩下的即可，回合数为 $3$。

对样例二， $b_1=3,b_2=(3+500000002+500000002+3)\bmod10^9+7=3$ ，可以发现无论先手怎么取，后手都有对应的策略使得后手必胜。一种回合情况为先手投第二个源泉 $3$ 魔力，后手投第一个源泉 $3$ 魔力，回合数为 $2$ 。

注意样例二不能采用诸如这样的策略：$(1,3),(2,1),(2,1),(2,1)$  ，这是因为若第二回合后手进行 $(2,1)$ ；在第三回合，先手若采用对自己的最优策略，可以直接用 $(2,2)$ 取得胜利，从而逆转为胜利；这也意味着第二回合后手不可能是 $(2,1)$ 。

###### 子任务

```c++
s[11-19] 5
s[21-29] 5
s[31-39] 10
s[41-49] 10
```

###### SPJ

```c++
#include "testlib.h"
using namespace std;
typedef long long ll;
#define mn 100010
ll a[mn], b[mn], n, p = 1e9 + 7, t, xors;
string ans1, ans2, out1, out2;
signed main(int argc, char *argv[])
{
    registerTestlibCmd(argc, argv);
    n = inf.readLong();
    for (ll i = 1, n2 = 1; i <= n; ++i, n2 = n2 * 2 % p)
    {
        a[i] = inf.readLong();
        a[i] = (a[i] + a[i - 1]) % p;
        b[i] = n2 * a[i] % p;
        xors ^= b[i];
    }
    ans1 = ans.readString();
    ans2 = ans.readString();
    out1 = ouf.readString();
    out2 = ouf.readString();
    if (ans1 != out1 || ans2 != out2)
    {
        quitf(_wa, "WA of judgements");
    }
    t = ouf.readLong();
    if (t <= 0 || t > 2 * n)
    {
        quitf(_wa, "incorrect t");
    }
    for (ll i = 0, x, y, xorpre = xors; i < t; ++i, xorpre = xors)
    {
        x = ouf.readLong();
        y = ouf.readLong();
        if (b[x] < y || y <= 0)
        {
            quitf(_wa, "out of range");
        }
        xors ^= b[x];
        b[x] -= y;
        xors ^= b[x];
        if (xors * xorpre || !(xors + xorpre))
        {
            quitf(_wa, "incorrect movement");
        }
    }
    for (ll i = 1; i <= n; ++i)
    {
        if (b[i] != 0)
        {
            quitf(_wa, "remains unsolved");
        }
    }
    quitf(_ok, "AC");
}
```

